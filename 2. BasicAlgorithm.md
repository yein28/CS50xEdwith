# 알고리즘 기초

**1. 알고리즘**

- 입력값을 출력값의 형태로 바꾸기 위해 어떤 명령을 수행되어야 하는지에 대한 규칙들의 순서적 나열

- 입력을 출력으로 바꾸기 위해 컴퓨터가 따르는 일련의 절차

  <br>


**2. 의사코드** 

- 프로그래밍 언어보다 문법적 제약을 적게 받으므로 알고리즘 표현에 많이 사용


<br>

**3. 선형탐색**

- 원하는 원소가 발견될 때까지 처음붵 마지막까지 차례대로 탐색
- 유용한 경우 -> 원소들이 정렬되어있지 않은 경우, 사전에 아무런 정보도 없는 경우


<br>

**4. 버블 정렬**

- 앞에서부터 두개의 인접한 자료를 비교하면서 큰값이 오른쪽이 가도록 swap
- n개의 원소에 대해 버블 정렬을 1번 수행할 때 마다 n번째 원소가 제자리 찾음, 그 다음 정렬에서는 n-1개의 원소를 정렬 시킴
- 최악의 경우 n개의 요소 정렬위해 n-1번 정렬 해야함 => 비효율


<br>

**5. 선택 정렬**

- 정렬할 자료 중에서 가장 작은 수(or 큰 수)를 찾아 첫 번째 위치(or 마지막 위치)의 수와 교환
- 교환 횟수는 최소화 but 비교의 횟수는 증가
- 무조건 n-1번의 교환이 필요
- 1번의 교환을 위해 정렬되지 않은 수의 모든 비교가 필요,  n^2의 비교가 이루어짐 
- 최선의 경우, 최악의 경우 모두 비교와 교환 횟수 같음


<br>

**6. 삽입 정렬**

- 자료의 비교나 교환이 필요 X,  정렬되지 않은 부분의 자료가 정렬된 부분의 자리로 삽입되는 형태 
- 자료의 양이 적을 때 성능이 우수, 자료의 대부분이 이미 정렬되어있는 경우 효율적 
- 새로운 자료가 삽입되어야하는 경우 정렬된 자료들이 자리를 이동해야함 -> 안전성 낮음

<br>

**7. 시간복잡도**

- 알고리즘을 수행할때 걸리는 시간을 기준으로 효율성을 분석

O(1) -> N의 크기는 상관없음

**O(n)** : Upper Bound, 상한, **대략을 나타내는 개념, 최악의 경우에 대한 시간복잡도**

**Ω(n)** : Lower Bound, 하한, **최선의 경우**

<br>

만약 O(X)와 Ω(X)가 있을 때 두 개의 괄호 안의 값이 서로 같을 경우 Θ로 표현 가능

Θ(n)  -> big O 값과 오메가의 값이 같다는 뜻

| Algorithm |    Big O    | Big Ω  |
| :-------: | :---------: | :----: |
| 선형 탐색 |    O(n)     |  Ω(1)  |
| 이진 탐색 | O( log(n) ) |  Ω(1)  |
| 버블 정렬 |   O(n^2)    |  Ω(n)  |
| 삽입 정렬 |   O(n^2)    |  Ω(n)  |
| 선택 정렬 |   O(n^2)    | Ω(n^2) |

Big Ω 표기법 

- 선형 탐색 : 최선의 경우는 찾고자 하는 값이 처음에 있는 경우, 배열의 크기와 상관없이 Ω(1)
- 버블 정렬 :  배열이 이미 정렬되어있더라도 그 사실을 알수 없기 때문에 n-1번의 비교 필요, Ω(n)
- 선택 정렬 : 마찬가지로 배열이 정렬되어있는 것을 알 수 없음, 최소값을 계속 찾아야 하므로 Ω(n^2)
- 삽입 정렬 : 정렬되지 않은 부분에서 정렬된 부분으로 옮겨갈 때, 정렬된 부분의 가장 큰수와 비교 하면되므로 Ω(n)


<br>

**8. 합병 정렬(merge Sort)** 

- 시간면에서 우수하지만 공간이 더 많이 필요함
- 원소가 한 개가 될 때까지 반으로 나누다가 합쳐나가면서 정렬
-  n개의 원소는 log n번  나누기를 수행
  - 병합되면서 원소들의 크기를 비교하기 때문에 n번의 비교과정 필요 
  - 그러므로 시간복잡도는 O(n log n)
- T(n) = T(n/2) + T(n/2) + O(n)
  - T(n/2) 왼쪽, 오른쪽, O(n) ->자료를 비교하는 단계

<br>

**9. 이진 탐색**

- 정렬이 되어있는 경우 사용
- O(log n)

